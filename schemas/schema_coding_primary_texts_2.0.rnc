# Schema follows some of the EpiDoc guidelines (http://www.stoa.org/epidoc/gl/latest/), and equivalencies are noted in comments.

# Document always refers to the entire textual unit in question, from a half page archival document to a 500 page manuscript. 
# Most documents annotated in XML using this schema will only be a few pages.

start = document
document = element document { metadata, body }


# METADATA
# In previous versions a lot more metadata was held at the document level. 
# However, for now all information but the document Unique ID will be held in the relational database instead (which is why the previous categories are commented out).

metadata = element metadata { unique_id }
unique_id = element unique_id { text }

# metadata =
#    element metadata {
#        archive, serial, entity, language, original, complete, cat_gloss, cat_date, gloss, keywords
#    }
# archive = element archive { arc_name, call, fol }
# arc_name = element name { "IVANUz" | "NAI" | "RGVIA" | "RGIA" | "TsGARUz" | "USSR" }
# Refers to Archive Acronym
# call = element call { text }
# fol = element fol { text }
# serial = element serial { xsd:int }
# Internal reference number
# entity = element entity { "Bukhara" | "Britain" | "Hyderabad" | "Russia" | "USSR" }
# The political entity that produced the document
# original = element original { original_type }
# original_type = attribute type { "original" | "scan" | "notes" | "photocopy" }
# Copy of the document, scan, or just notes
# complete = element complete { complete_type }
# complete_type = attribute type { "yes" | "partial" | "errors" }
# PROBLEM: need to make repeatable
# cat_gloss = element cat_gloss { text }
# The actual catalog description (in original language of the catelog, but transcribed into Roman characters)
# cat_date =
#    element cat_date {
#        mixed { (jul_date? | greg_date? | hij_date?)* }
#    }
jul_date = attribute jul_date { text }
greg_date = attribute greg_date { text }
hij_date = attribute hij_date { text }
# gloss = element gloss { text }
# An ad-hoc description of the contents (in English)
# keywords = element keywords { text }
# Misc keywords of possible interest; no attempt to standardize or limit

# BODY TEXT
# __Body__ contains the entire text of the 'document'

# (I) Diplomatic Annotation

body = element body { (doc_div* | pg?)* }

#  (i-a) Page number is a milestone element; attribute Folio refers to internal pagination
pg = element pg { folio, empty }
folio = attribute folio { text }
page = attribute page { text }


# (i-b) Document division can refer to any kind of structural divider within a text: paragraph, invocatio, diagonal writing, etc.

doc_div =
    element div {
        div_type,
        mixed {
            (doc_div
             | individual
             | intertext
             | language
             | lb
             | ts
             | term
             | location
             | emic_id
             | date
             | pg
             | flag
             | honorific
             | financial
             | legal)*
        }
    }

# removed from permissible attribute values: "closing", "couplet", and "preamble", because these are all topical structures, and should therefore be captured by <ts>
# removed from permissible attricute values: "line" which is now a separate element (<lb>); "gloss" (contained in relational database); and "report (specific to Russian documents, which will not use this schema)

div_type =
    attribute type { "heading" | "marginalia" | "section" | "sentence" }

# (i-c) Lines
# I don't see any reason to code lines as milestones, as in EpiDoc. 
# I previously coded lines as an attribute of <div>, but switched them to their own element just because that was cumbersome.

lb =
    element lb {
        mixed {
            (doc_div
             | individual
             | intertext
             | language
             | term
             | lb
             | ts
             | location
             | emic_id
             | date
             | pg
             | flag
             | honorific
             | financial
             | legal)*
        }
    }
# lb = element lb { mixed {(flag)}*}


# Marginalia references, local to the document: TBD. This is done in TEI using <metamark> (http://tei.oucs.ox.ac.uk/release/doc/tei-p5-doc/en/html/ref-metamark.html).
# Will involve empty element citation-style references, e.g. <s n="note1"/> <e n="note1"/> surrounding the marginal note, and then seomething like <note n="note1"/> in the text.


# (II) Thematic Sections

# The milestone element <ts> ("thematic section) is used for coding the topical structure of document.
# It uses conventions established for medieval diplomatics:
# "The introduction comprises, first, the invocation (invocatio) of God, either by name or through a symbol such as the cross; 
# second, the superscription (intitulatio), giving the name and title of the sender; 
# and third, the address (inscriptio), naming those to whom the document is directed, 
# usually followed by a formula of greeting (salutatio)."

ts = element ts { ts_type, empty }
ts_type = attribute type { "salutatio" | "narratio" | "inscriptio" | "intitulatio" | "invocatio" }


# (III) Transcription Annotation

# Dealing with transcription problems in the text. TEI EpiDoc uses the following conventions (inter alia):
# Illegible Characters, Quantity Unknown: <gap reason="illegible" extent="unknown"unit="character"/>. Here this corresponds to <flag type=gap>
# Ambiguous Characters: <unclear>, with a more complicated variant when possible alternatives are offered (http://www.stoa.org/epidoc/gl/latest/trans-ambiguousalt.html). Here this corresponds to <flag type="unclear">.

flag = element flag { flag_type, text }
flag_type = attribute type { "orthography" | "transcription" | "meaning" | "unclear" | "gap" }


# (IV) Historical Annotation

# These categories overlap with tables in the relational database. However, this markup will mostly be used to extract information from the documents (at least initially).
# For the most part, I will not be manually marking strings that I know are common and can easily be captured by a machine, at least initially.

# (iv-a) Individuals 
# Corresponding relational database table titled "Prosopography."
# This is used exclusively for proper nouns, i.e. when the name of an individual is referenced. (Previously I coded implicit references as well: no longer.)

individual =
    element individual {
        mixed { ind_id?, (role? | honorific? | location? | flag?)* }
    }
ind_id = attribute id { text }

 
# (iv-b) Locations
# Corresponding to relational database table titled "Gazetteer."
# Places, institutions, etc.

location = element location { loc_id?, text }
loc_id = attribute id { text }
# will eventually be an idref#
emic_id = element emic_id { emic_type, text }
emic_type = attribute type { text }


# (iv-c) Social Role
# Any generalized term that refers to a person (e.g. military rank, confession, ethnicity).

role = element role { role_id, text }
role_id = attribute id { text }

# (iv-d) Knowledge Form


# (iv-e) Technical Terminology

term = element term { term_type?, text }
term_type = attribute type { "admin" | "genre" | "order" }




# Defunct: "honorific" as a category should be phased out.
honorific =
    element honorific {
        mixed { pg? }
    }
    
 



# __Date__ format is day/month/year for all three
date =
    element date {
        mixed { jul_date | greg_date | hij_date }
    }

# __Intertextual Reference__ with separate ids for Qur'an, Hadith, and references to the Bibliography (text_id)
intertext =
    element intertext {
        mixed { quran_id | hadith_id | text_id }
    }
quran_id = attribute quran_id { text }
hadith_id = attribute hadith_id { text }
text_id = attribute text_id { text }


# Topical Coding
# __Language__ tracks linguistic points of note within a text
language = element language { language_type, text }
language_type =
    attribute type {
        list { ("grammar" | "vocab" | "tajik" | "turkic" | "urdu" | "persian" | "russian")+ }
    }
        
# __Financial__ data, e.g. prices, salaries, etc.
financial = element financial { financial_type, text }
financial_type = attribute type { "salary" | "price" | "debt" }
# __Legal__ tracks legal terms
legal = element legal { text }
